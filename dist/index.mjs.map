{"version":3,"sources":["../src/classes/Errors.ts","../src/classes/YoutubeVideo.ts","../src/util/Decipher.ts","../src/util/Formats.ts","../src/util/Config.ts","../src/util/Util.ts","../src/functions/GetVideo.ts","../src/functions/Download.ts"],"sourcesContent":["export class YoutubeError extends Error {\n    name = 'YoutubeError';\n    constructor(message?: string) {\n        super(message);\n    }\n}\n\nexport class UrlError extends Error {\n    name = 'UrlError';\n    constructor(message?: string) {\n        super(message);\n        this.message ||= 'An invalid url is provided.';\n    }\n}\n\nexport class FormatError extends Error {\n    name = 'FormatError';\n    constructor(message?: string) {\n        super(message);\n        this.message ||= 'Cannot find suitable format for this download.';\n    }\n}\n","import Axios from 'axios';\n\nimport m3u8stream from 'm3u8stream';\n\nimport { PassThrough, Readable } from 'stream';\n\nimport { FormatError } from './Errors';\n\nimport { decipher } from '../util/Decipher';\n\nimport { formats as FormatStructs } from '../util/Formats';\nimport { Util, YoutubeConfig } from '../util';\n\nimport { Download } from '../functions';\nimport { HttpsProxyAgent } from 'https-proxy-agent';\n\nexport interface YoutubeVideoDetails {\n    id: string;\n    url: string;\n    title: string;\n    thumbnails: {\n        url: string;\n        width: string;\n        height: string;\n    }[];\n    description: string;\n    duration: number;\n    viewCount: number;\n    author: string;\n    channelId: string;\n    keywords: string[];\n    allowRatings: boolean;\n    averageRating: number;\n    isOwnerViewing: boolean;\n    isCrawlable: boolean;\n    isUnpluggedCorpus: boolean;\n    isPrivate: boolean;\n    isLiveContent: boolean;\n    formats: YoutubeVideoFormat[];\n}\n\nexport interface YoutubeVideoFormat {\n    itag: keyof typeof FormatStructs;\n    mimeType: string;\n    qualityLabel: string | null;\n    bitrate: number | null;\n    audioBitrate: number | null;\n    codec: string;\n    type: string;\n    width?: number;\n    height?: number;\n    initRange?: {\n        start: number;\n        end: number;\n    };\n    indexRange?: {\n        start: number;\n        end: number;\n    };\n    lastModifiedTimestamp?: number;\n    contentLength?: number;\n    quality?: string;\n    audioChannels?: number;\n    audioSampleRate?: number;\n    loudnessDb?: number;\n    s?: string;\n    sp?: string;\n    fps?: number;\n    projectionType?: 'RECTANGULAR';\n    averageBitrate?: number;\n    approxDurationMs?: number;\n    signatureCipher?: string;\n\n    // Provided by addFormats().\n    url: string;\n\n    // Provided by Util.getMetadataFormat().\n    hasAudio: boolean;\n    hasVideo: boolean;\n    isLive: boolean;\n    isHLS: boolean;\n    isDashMPD: boolean;\n}\n\nexport interface DownloadOptions {\n    resource?: PassThrough;\n    highWaterMark?: number;\n    begin?: number | string;\n    liveBuffer?: number;\n    chunkSize?: number;\n    start?: number;\n    remainRetry?: number;\n}\n\nexport class YoutubeVideo {\n    json: any;\n\n    liveFormats: YoutubeVideoFormat[] = [];\n    normalFormats: YoutubeVideoFormat[] = [];\n\n    constructor(json: any) {\n        this.json = json;\n\n        this.addFormats([...(json.streamingData?.formats ?? []), ...(json.streamingData?.adaptiveFormats ?? [])]);\n    }\n\n    get url(): string {\n        return Util.getVideoURL(this.json.videoDetails.videoId);\n    }\n\n    get details(): YoutubeVideoDetails {\n        return {\n            id: this.json.videoDetails.videoId,\n            url: Util.getVideoURL(this.json.videoDetails.videoId),\n            title: this.json.videoDetails.title,\n            thumbnails: this.json.videoDetails.thumbnail.thumbnails,\n            description: this.json.videoDetails.shortDescription,\n            duration: Number(this.json.videoDetails.lengthSeconds) * 1000,\n            viewCount: Number(this.json.videoDetails.viewCount),\n            author: this.json.videoDetails.author,\n            channelId: this.json.videoDetails.channelId,\n            keywords: this.json.videoDetails.keywords,\n            allowRatings: this.json.videoDetails.allowRatings,\n            averageRating: this.json.videoDetails.averageRating,\n            isOwnerViewing: this.json.videoDetails.isOwnerViewing,\n            isCrawlable: this.json.videoDetails.isCrawlable,\n            isUnpluggedCorpus: this.json.videoDetails.isUnpluggedCorpus,\n            isPrivate: this.json.videoDetails.isPrivate,\n            isLiveContent: this.json.videoDetails.isLiveContent,\n            formats: this.formats\n        };\n    }\n\n    get formats(): YoutubeVideoFormat[] {\n        return [...this.liveFormats, ...this.normalFormats];\n    }\n\n    Download(\n        formatFilter: (f: YoutubeVideoFormat) => boolean,\n        options: DownloadOptions = {},\n        Proxy?: { Host: string; Port: number }\n    ): m3u8stream.Stream | PassThrough {\n        // This format filter is playable video or audio.\n        const playableFormats = this.formats.filter((f) => f.isHLS || (f.contentLength && (f.hasVideo || f.hasAudio)));\n        const filteredFormats = playableFormats.filter(formatFilter);\n\n        // Choose last available format because format is ascending order.\n        const format = filteredFormats[filteredFormats.length - 1] ?? playableFormats[playableFormats.length - 1];\n        if (!format) {\n            throw new FormatError();\n        }\n\n        if (format.isHLS) {\n            const stream = m3u8stream(format.url, {\n                id: String(format.itag),\n                parser: 'm3u8',\n                highWaterMark: options.highWaterMark ?? 64 * 1024,\n                begin: options.begin ?? (format.isLive ? Date.now() : 0),\n                liveBuffer: options.liveBuffer ?? 4000,\n                requestOptions: {\n                    maxReconnects: Infinity,\n                    maxRetries: 10,\n                    backoff: { inc: 20, max: 100 },\n                    agent: Proxy ? new HttpsProxyAgent(`http://${Proxy.Host}:${Proxy.Port}`) : undefined\n                }\n            });\n\n            stream.once('close', () => {\n                stream.end();\n            });\n\n            return stream;\n        } else {\n            const downloadChunkSize = options.chunkSize ?? 256 * 1024,\n                remainRetry = options.remainRetry ?? 10;\n\n            let startBytes = options.start ?? 0,\n                endBytes = startBytes + downloadChunkSize;\n\n            let awaitDrain: (() => void) | null = null;\n\n            let nowBody: Readable | null = null;\n\n            let retryTimer: Timer | null = null;\n\n            const stream =\n                options.resource ??\n                new PassThrough({\n                    highWaterMark: options.highWaterMark ?? 64 * 1024\n                })\n                    .on('drain', () => {\n                        awaitDrain?.();\n                        awaitDrain = null;\n                    })\n                    .once('close', () => {\n                        nowBody?.destroy();\n                        nowBody = null;\n                        clearTimeout(retryTimer as NodeJS.Timeout);\n                        retryTimer = null;\n                    });\n\n            const getRangeChunk = async () => {\n                try {\n                    const response = await Axios(format.url, {\n                        headers: {\n                            range: `bytes=${startBytes}-${\n                                endBytes >= (format.contentLength as number) ? '' : endBytes\n                            }`,\n                            referer: 'https://www.youtube.com/'\n                        },\n                        proxy: Proxy ? { host: Proxy.Host, port: Proxy.Port } : false\n                    });\n\n                    if (response.status[0] !== 2) {\n                        if (response.status === 403 && remainRetry > 0) {\n                            // Retry download when status code is 403.\n                            options.resource = stream;\n                            options.start = startBytes;\n                            options.remainRetry = remainRetry - 1;\n                            retryTimer = setTimeout(Download, 150, this.url, options);\n                        } else {\n                            stream.destroy(new Error(`Cannot retry download with status code ${response.status}`));\n                        }\n\n                        return;\n                    }\n\n                    const reader = response.data as Readable;\n                    if (!reader) {\n                        throw new Error('Cannot get readable stream from response body.');\n                    }\n\n                    let chunk = await reader.read();\n\n                    while (!chunk.done) {\n                        if (stream.destroyed) {\n                            return;\n                        }\n\n                        startBytes += chunk.value.length;\n                        if (!stream.write(chunk.value)) {\n                            await new Promise((resolve) => stream.once('drain', resolve));\n                        }\n\n                        chunk = await reader.read();\n                    }\n\n                    if (stream.destroyed || startBytes >= (format.contentLength as number)) {\n                        return;\n                    }\n\n                    endBytes = startBytes + downloadChunkSize;\n                    getRangeChunk();\n                } catch (error) {\n                    stream.destroy(error as Error);\n                }\n            };\n\n            getRangeChunk();\n            return stream;\n        }\n    }\n\n    private addFormats(formats: any[]): void {\n        for (const rawFormat of formats) {\n            const itag = rawFormat.itag as keyof typeof FormatStructs;\n            const reservedFormat = FormatStructs[itag];\n\n            if (reservedFormat) {\n                const mimeType = rawFormat.mimeType ?? reservedFormat.mimeType;\n                let format: Partial<YoutubeVideoFormat> = {\n                    itag,\n                    mimeType,\n                    codec: mimeType.split('\"')[1],\n                    type: mimeType.split(';')[0],\n                    qualityLabel: rawFormat.qualityLabel ?? reservedFormat.qualityLabel,\n                    bitrate: rawFormat.bitrate ?? reservedFormat.bitrate,\n                    audioBitrate: reservedFormat.audioBitrate,\n                    width: rawFormat.width,\n                    height: rawFormat.height,\n                    initRange: {\n                        start: Number(rawFormat.initRange?.start),\n                        end: Number(rawFormat.initRange?.end)\n                    },\n                    indexRange: {\n                        start: Number(rawFormat.indexRange?.start),\n                        end: Number(rawFormat.indexRange?.end)\n                    },\n                    lastModifiedTimestamp: Number(rawFormat.lastModified),\n                    contentLength: Number(rawFormat.contentLength),\n                    quality: rawFormat.quality,\n                    fps: rawFormat.fps,\n                    projectionType: rawFormat.projectionType,\n                    averageBitrate: rawFormat.averageBitrate,\n                    approxDurationMs: Number(rawFormat.approxDurationMs),\n                    signatureCipher: rawFormat.signatureCipher ?? rawFormat.cipher\n                };\n\n                if (rawFormat.url && !format.signatureCipher) {\n                    format.url = rawFormat.url;\n                } else if (!rawFormat.url && format.signatureCipher) {\n                    format = { ...format, ...Object.fromEntries(new URLSearchParams(format.signatureCipher)) };\n                }\n\n                const url = new URL(format.url as string);\n\n                url.searchParams.set('ratebypass', 'yes');\n                if (YoutubeConfig.PLAYER_TOKENS && format.s) {\n                    url.searchParams.set(format.sp ?? 'signature', decipher(YoutubeConfig.PLAYER_TOKENS, format.s));\n                }\n\n                format.url = url.toString();\n\n                this.normalFormats.push(Util.getMetadataFormat(format as YoutubeVideoFormat));\n            }\n        }\n    }\n}\n","const jsVarStr = '[a-zA-Z_\\\\$]\\\\w*';\nconst jsSingleQuoteStr = `'[^'\\\\\\\\]*(:?\\\\\\\\[\\\\s\\\\S][^'\\\\\\\\]*)*'`;\nconst jsDoubleQuoteStr = `\"[^\"\\\\\\\\]*(:?\\\\\\\\[\\\\s\\\\S][^\"\\\\\\\\]*)*\"`;\nconst jsQuoteStr = `(?:${jsSingleQuoteStr}|${jsDoubleQuoteStr})`;\nconst jsKeyStr = `(?:${jsVarStr}|${jsQuoteStr})`;\nconst jsPropStr = `(?:\\\\.${jsVarStr}|\\\\[${jsQuoteStr}\\\\])`;\nconst jsEmptyStr = `(?:''|\"\")`;\nconst reverseStr = ':function\\\\(a\\\\)\\\\{(?:return )?a\\\\.reverse\\\\(\\\\)\\\\}';\nconst sliceStr = ':function\\\\(a,b\\\\)\\\\{return a\\\\.slice\\\\(b\\\\)\\\\}';\nconst spliceStr = ':function\\\\(a,b\\\\)\\\\{a\\\\.splice\\\\(0,b\\\\)\\\\}';\nconst swapStr =\n    ':function\\\\(a,b\\\\)\\\\{' +\n    'var c=a\\\\[0\\\\];a\\\\[0\\\\]=a\\\\[b(?:%a\\\\.length)?\\\\];a\\\\[b(?:%a\\\\.length)?\\\\]=c' +\n    '(?:;return a)?\\\\}';\nconst actionsObjRegexp = new RegExp(\n    `var (${jsVarStr})=\\\\{((?:(?:${jsKeyStr}${reverseStr}|${jsKeyStr}${sliceStr}|${jsKeyStr}${spliceStr}|${jsKeyStr}${swapStr}),?\\\\r?\\\\n?)+)\\\\};`\n);\nconst actionsFuncRegexp = new RegExp(\n    `function(?: ${jsVarStr})?\\\\(a\\\\)\\\\{` +\n        `a=a\\\\.split\\\\(${jsEmptyStr}\\\\);\\\\s*` +\n        `((?:(?:a=)?${jsVarStr}${jsPropStr}\\\\(a,\\\\d+\\\\);)+)` +\n        `return a\\\\.join\\\\(${jsEmptyStr}\\\\)\\\\}`\n);\nconst reverseRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${reverseStr}`, 'm');\nconst sliceRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${sliceStr}`, 'm');\nconst spliceRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${spliceStr}`, 'm');\nconst swapRegexp = new RegExp(`(?:^|,)(${jsKeyStr})${swapStr}`, 'm');\n\nexport function decipher(tokens: string[], sig: string): string {\n    let arr = sig.split('');\n\n    for (const token of tokens) {\n        const position = Number(token.slice(1));\n\n        switch (token[0]) {\n            case 'r':\n                arr.reverse();\n                break;\n            case 's':\n                arr = arr.slice(position);\n                break;\n            case 'p':\n                arr.splice(0, position);\n                break;\n            case 'w':\n                [arr[0], arr[position % arr.length]] = [arr[position % arr.length], arr[0]];\n                break;\n        }\n    }\n\n    return arr.join('');\n}\n\nexport function extractTokens(body: string): string[] | null {\n    const objResult = actionsObjRegexp.exec(body);\n    const funcResult = actionsFuncRegexp.exec(body);\n    if (!objResult || !funcResult) {\n        return null;\n    }\n\n    const obj = objResult[1].replace(/\\$/g, '\\\\$');\n    const objBody = objResult[2].replace(/\\$/g, '\\\\$');\n    const funcBody = funcResult[1].replace(/\\$/g, '\\\\$');\n\n    const reverseKey = reverseRegexp\n        .exec(objBody)?.[1]\n        .replace(/\\$/g, '\\\\$')\n        .replace(/\\$|^'|^\"|'$|\"$/g, '');\n    const sliceKey = sliceRegexp\n        .exec(objBody)?.[1]\n        .replace(/\\$/g, '\\\\$')\n        .replace(/\\$|^'|^\"|'$|\"$/g, '');\n    const spliceKey = spliceRegexp\n        .exec(objBody)?.[1]\n        .replace(/\\$/g, '\\\\$')\n        .replace(/\\$|^'|^\"|'$|\"$/g, '');\n    const swapKey = swapRegexp\n        .exec(objBody)?.[1]\n        .replace(/\\$/g, '\\\\$')\n        .replace(/\\$|^'|^\"|'$|\"$/g, '');\n\n    const keys = `(${reverseKey}|${sliceKey}|${spliceKey}|${swapKey})`;\n    const tokenizeRegexp = new RegExp(`(?:a=)?${obj}(?:\\\\.${keys}|\\\\[(?:'${keys}'|\"${keys}\")\\\\])\\\\(a,(\\\\d+)\\\\)`, 'g');\n    const tokens: string[] = [];\n    for (const result of funcBody.matchAll(tokenizeRegexp)) {\n        const key = result[1] || result[2] || result[3];\n        switch (key) {\n            case reverseKey:\n                tokens.push('r');\n                break;\n            case sliceKey:\n                tokens.push(`s${result[4]}`);\n                break;\n            case spliceKey:\n                tokens.push(`p${result[4]}`);\n                break;\n            case swapKey:\n                tokens.push(`w${result[4]}`);\n                break;\n        }\n    }\n    return tokens;\n}\n","// Reference: http://en.wikipedia.org/wiki/YouTube#Quality_and_formats\n\nexport const formats = {\n    5: {\n        mimeType: 'video/flv; codecs=\"Sorenson H.263, mp3\"',\n        qualityLabel: '240p',\n        bitrate: 250000,\n        audioBitrate: 64\n    },\n    6: {\n        mimeType: 'video/flv; codecs=\"Sorenson H.263, mp3\"',\n        qualityLabel: '270p',\n        bitrate: 800000,\n        audioBitrate: 64\n    },\n    13: {\n        mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n        qualityLabel: null,\n        bitrate: 500000,\n        audioBitrate: null\n    },\n    17: {\n        mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n        qualityLabel: '144p',\n        bitrate: 50000,\n        audioBitrate: 24\n    },\n    18: {\n        mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n        qualityLabel: '360p',\n        bitrate: 500000,\n        audioBitrate: 96\n    },\n    22: {\n        mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n        qualityLabel: '720p',\n        bitrate: 2000000,\n        audioBitrate: 192\n    },\n    34: {\n        mimeType: 'video/flv; codecs=\"H.264, aac\"',\n        qualityLabel: '360p',\n        bitrate: 500000,\n        audioBitrate: 128\n    },\n    35: {\n        mimeType: 'video/flv; codecs=\"H.264, aac\"',\n        qualityLabel: '480p',\n        bitrate: 800000,\n        audioBitrate: 128\n    },\n    36: {\n        mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n        qualityLabel: '240p',\n        bitrate: 175000,\n        audioBitrate: 32\n    },\n    37: {\n        mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n        qualityLabel: '1080p',\n        bitrate: 3000000,\n        audioBitrate: 192\n    },\n    38: {\n        mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n        qualityLabel: '3072p',\n        bitrate: 3500000,\n        audioBitrate: 192\n    },\n    43: {\n        mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n        qualityLabel: '360p',\n        bitrate: 500000,\n        audioBitrate: 128\n    },\n    44: {\n        mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n        qualityLabel: '480p',\n        bitrate: 1000000,\n        audioBitrate: 128\n    },\n    45: {\n        mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n        qualityLabel: '720p',\n        bitrate: 2000000,\n        audioBitrate: 192\n    },\n    46: {\n        mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n        qualityLabel: '1080p',\n        bitrate: null,\n        audioBitrate: 192\n    },\n    82: {\n        mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n        qualityLabel: '360p',\n        bitrate: 500000,\n        audioBitrate: 96\n    },\n    83: {\n        mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n        qualityLabel: '240p',\n        bitrate: 500000,\n        audioBitrate: 96\n    },\n    84: {\n        mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n        qualityLabel: '720p',\n        bitrate: 2000000,\n        audioBitrate: 192\n    },\n    85: {\n        mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n        qualityLabel: '1080p',\n        bitrate: 3000000,\n        audioBitrate: 192\n    },\n    91: {\n        mimeType: 'video/ts; codecs=\"H.264, aac\"',\n        qualityLabel: '144p',\n        bitrate: 100000,\n        audioBitrate: 48\n    },\n    92: {\n        mimeType: 'video/ts; codecs=\"H.264, aac\"',\n        qualityLabel: '240p',\n        bitrate: 150000,\n        audioBitrate: 48\n    },\n    93: {\n        mimeType: 'video/ts; codecs=\"H.264, aac\"',\n        qualityLabel: '360p',\n        bitrate: 500000,\n        audioBitrate: 128\n    },\n    94: {\n        mimeType: 'video/ts; codecs=\"H.264, aac\"',\n        qualityLabel: '480p',\n        bitrate: 800000,\n        audioBitrate: 128\n    },\n    95: {\n        mimeType: 'video/ts; codecs=\"H.264, aac\"',\n        qualityLabel: '720p',\n        bitrate: 1500000,\n        audioBitrate: 256\n    },\n    96: {\n        mimeType: 'video/ts; codecs=\"H.264, aac\"',\n        qualityLabel: '1080p',\n        bitrate: 2500000,\n        audioBitrate: 256\n    },\n    100: {\n        mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n        qualityLabel: '360p',\n        bitrate: null,\n        audioBitrate: 128\n    },\n    101: {\n        mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n        qualityLabel: '360p',\n        bitrate: null,\n        audioBitrate: 192\n    },\n    102: {\n        mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n        qualityLabel: '720p',\n        bitrate: null,\n        audioBitrate: 192\n    },\n    120: {\n        mimeType: 'video/flv; codecs=\"H.264, aac\"',\n        qualityLabel: '720p',\n        bitrate: 2000000,\n        audioBitrate: 128\n    },\n    127: {\n        mimeType: 'audio/ts; codecs=\"aac\"',\n        qualityLabel: null,\n        bitrate: null,\n        audioBitrate: 96\n    },\n    128: {\n        mimeType: 'audio/ts; codecs=\"aac\"',\n        qualityLabel: null,\n        bitrate: null,\n        audioBitrate: 96\n    },\n    132: {\n        mimeType: 'video/ts; codecs=\"H.264, aac\"',\n        qualityLabel: '240p',\n        bitrate: 150000,\n        audioBitrate: 48\n    },\n    133: {\n        mimeType: 'video/mp4; codecs=\"H.264\"',\n        qualityLabel: '240p',\n        bitrate: 200000,\n        audioBitrate: null\n    },\n    134: {\n        mimeType: 'video/mp4; codecs=\"H.264\"',\n        qualityLabel: '360p',\n        bitrate: 300000,\n        audioBitrate: null\n    },\n    135: {\n        mimeType: 'video/mp4; codecs=\"H.264\"',\n        qualityLabel: '480p',\n        bitrate: 500000,\n        audioBitrate: null\n    },\n    136: {\n        mimeType: 'video/mp4; codecs=\"H.264\"',\n        qualityLabel: '720p',\n        bitrate: 1000000,\n        audioBitrate: null\n    },\n    137: {\n        mimeType: 'video/mp4; codecs=\"H.264\"',\n        qualityLabel: '1080p',\n        bitrate: 2500000,\n        audioBitrate: null\n    },\n    138: {\n        mimeType: 'video/mp4; codecs=\"H.264\"',\n        qualityLabel: '4320p',\n        bitrate: 13500000,\n        audioBitrate: null\n    },\n    139: {\n        mimeType: 'audio/mp4; codecs=\"aac\"',\n        qualityLabel: null,\n        bitrate: null,\n        audioBitrate: 48\n    },\n    140: {\n        mimeType: 'audio/m4a; codecs=\"aac\"',\n        qualityLabel: null,\n        bitrate: null,\n        audioBitrate: 128\n    },\n    141: {\n        mimeType: 'audio/mp4; codecs=\"aac\"',\n        qualityLabel: null,\n        bitrate: null,\n        audioBitrate: 256\n    },\n    151: {\n        mimeType: 'video/ts; codecs=\"H.264, aac\"',\n        qualityLabel: '720p',\n        bitrate: 50000,\n        audioBitrate: 24\n    },\n    160: {\n        mimeType: 'video/mp4; codecs=\"H.264\"',\n        qualityLabel: '144p',\n        bitrate: 100000,\n        audioBitrate: null\n    },\n    171: {\n        mimeType: 'audio/webm; codecs=\"vorbis\"',\n        qualityLabel: null,\n        bitrate: null,\n        audioBitrate: 128\n    },\n    172: {\n        mimeType: 'audio/webm; codecs=\"vorbis\"',\n        qualityLabel: null,\n        bitrate: null,\n        audioBitrate: 192\n    },\n    242: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '240p',\n        bitrate: 100000,\n        audioBitrate: null\n    },\n    243: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '360p',\n        bitrate: 250000,\n        audioBitrate: null\n    },\n    244: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '480p',\n        bitrate: 500000,\n        audioBitrate: null\n    },\n    247: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '720p',\n        bitrate: 700000,\n        audioBitrate: null\n    },\n    248: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '1080p',\n        bitrate: 1500000,\n        audioBitrate: null\n    },\n    249: {\n        mimeType: 'audio/webm; codecs=\"opus\"',\n        qualityLabel: null,\n        bitrate: null,\n        audioBitrate: 48\n    },\n    250: {\n        mimeType: 'audio/webm; codecs=\"opus\"',\n        qualityLabel: null,\n        bitrate: null,\n        audioBitrate: 64\n    },\n    251: {\n        mimeType: 'audio/webm; codecs=\"opus\"',\n        qualityLabel: null,\n        bitrate: null,\n        audioBitrate: 160\n    },\n    264: {\n        mimeType: 'video/mp4; codecs=\"H.264\"',\n        qualityLabel: '1440p',\n        bitrate: 4000000,\n        audioBitrate: null\n    },\n    266: {\n        mimeType: 'video/mp4; codecs=\"H.264\"',\n        qualityLabel: '2160p',\n        bitrate: 12500000,\n        audioBitrate: null\n    },\n    271: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '1440p',\n        bitrate: 9000000,\n        audioBitrate: null\n    },\n    272: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '4320p',\n        bitrate: 20000000,\n        audioBitrate: null\n    },\n    278: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '144p 30fps',\n        bitrate: 80000,\n        audioBitrate: null\n    },\n    298: {\n        mimeType: 'video/mp4; codecs=\"H.264\"',\n        qualityLabel: '720p',\n        bitrate: 3000000,\n        audioBitrate: null\n    },\n    299: {\n        mimeType: 'video/mp4; codecs=\"H.264\"',\n        qualityLabel: '1080p',\n        bitrate: 5500000,\n        audioBitrate: null\n    },\n    300: {\n        mimeType: 'video/ts; codecs=\"H.264, aac\"',\n        qualityLabel: '720p',\n        bitrate: 1318000,\n        audioBitrate: 48\n    },\n    302: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '720p HFR',\n        bitrate: 2500000,\n        audioBitrate: null\n    },\n    303: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '1080p HFR',\n        bitrate: 5000000,\n        audioBitrate: null\n    },\n    308: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '1440p HFR',\n        bitrate: 10000000,\n        audioBitrate: null\n    },\n    313: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '2160p',\n        bitrate: 13000000,\n        audioBitrate: null\n    },\n    315: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '2160p HFR',\n        bitrate: 20000000,\n        audioBitrate: null\n    },\n    330: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '144p HDR, HFR',\n        bitrate: 80000,\n        audioBitrate: null\n    },\n    331: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '240p HDR, HFR',\n        bitrate: 100000,\n        audioBitrate: null\n    },\n    332: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '360p HDR, HFR',\n        bitrate: 250000,\n        audioBitrate: null\n    },\n    333: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '240p HDR, HFR',\n        bitrate: 500000,\n        audioBitrate: null\n    },\n    334: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '720p HDR, HFR',\n        bitrate: 1000000,\n        audioBitrate: null\n    },\n    335: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '1080p HDR, HFR',\n        bitrate: 1500000,\n        audioBitrate: null\n    },\n    336: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '1440p HDR, HFR',\n        bitrate: 5000000,\n        audioBitrate: null\n    },\n    337: {\n        mimeType: 'video/webm; codecs=\"VP9\"',\n        qualityLabel: '2160p HDR, HFR',\n        bitrate: 12000000,\n        audioBitrate: null\n    }\n} as const;\n","import { extractTokens } from './Decipher';\n\n// IMPORTANT: INNERTUBE_CONTEXT client must be set to IOS in order to get HLS live formats\n\nexport class YoutubeConfig extends null {\n    static INNERTUBE_API_KEY = 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8';\n    static INNERTUBE_API_VERSION = 'v1';\n    static INNERTUBE_CLIENT_NAME = 'WEB';\n    static INNERTUBE_CLIENT_VERSION = '2.20231012.01.03';\n    static INNERTUBE_CONTEXT = {\n        client: {\n            clientName: 'IOS',\n            clientVersion: '19.09.3',\n            deviceModel: 'iPhone14,3',\n            userAgent: 'com.google.ios.youtube/19.09.3 (iPhone14,3; U; CPU iOS 15_6 like Mac OS X)'\n        }\n    };\n    static STS = 0;\n    static PLAYER_JS_URL = '';\n    static PLAYER_TOKENS: string[] | null = null;\n\n    static async fetchConfig(): Promise<void> {\n        try {\n            const response = await fetch('https://www.youtube.com/?hl=en');\n\n            const json = JSON.parse((/ytcfg.set\\(({.+?})\\);/s.exec(await response.text()) as RegExpExecArray)[1]);\n\n            YoutubeConfig.INNERTUBE_API_KEY = json.INNERTUBE_API_KEY;\n            YoutubeConfig.INNERTUBE_API_VERSION = json.INNERTUBE_API_VERSION;\n            YoutubeConfig.INNERTUBE_CONTEXT.client.clientVersion = YoutubeConfig.INNERTUBE_CLIENT_VERSION =\n                json.INNERTUBE_CLIENT_VERSION;\n            YoutubeConfig.STS = json.STS;\n\n            if (YoutubeConfig.PLAYER_JS_URL !== json.PLAYER_JS_URL) {\n                const response = await fetch(`https://www.youtube.com${json.PLAYER_JS_URL}`);\n                const player = await response.text();\n                YoutubeConfig.PLAYER_JS_URL = json.PLAYER_JS_URL;\n                YoutubeConfig.PLAYER_TOKENS = extractTokens(player);\n            }\n\n            setTimeout(YoutubeConfig.fetchConfig, 120 * 60 * 1000);\n        } catch {}\n    }\n}\n\nYoutubeConfig.fetchConfig();\n","import Parser from 'm3u8-parser';\n\nimport { YoutubeConfig } from './Config';\nimport { YoutubeVideoFormat } from '../classes';\nimport { inspect } from 'util';\nimport { formats } from './Formats';\n\nconst videoRegex = /^[\\w-]{11}$/;\nconst validPathDomains = /^https?:\\/\\/(youtu\\.be\\/|(www\\.)?youtube\\.com\\/(embed|v|shorts)\\/)/;\nconst validQueryDomains = ['youtube.com', 'www.youtube.com', 'm.youtube.com', 'music.youtube.com'];\n\nexport class Util extends null {\n    static getVideoURL(id: string): string {\n        return `https://www.youtube.com/watch?v=${id}`;\n    }\n\n    static getApiURL(param: string): string {\n        return `https://www.youtube.com/youtubei/v1/${param}?key=${YoutubeConfig.INNERTUBE_API_KEY}`;\n    }\n\n    static getVideoId(urlOrId: string, checkUrl: boolean = false): string | null {\n        try {\n            if (videoRegex.test(urlOrId) && !checkUrl) {\n                return urlOrId;\n            }\n            const url = new URL(urlOrId);\n            let id = url.searchParams.get('v');\n            if (validPathDomains.test(urlOrId) && !id) {\n                const paths = url.pathname.split('/');\n                id = paths[url.hostname === 'youtu.be' ? 1 : 2].slice(0, 11);\n            } else if (!validQueryDomains.includes(url.hostname)) {\n                return null;\n            }\n            return videoRegex.test(id ?? '') ? id : null;\n        } catch {\n            return null;\n        }\n    }\n\n    static getMetadataFormat(format: YoutubeVideoFormat): YoutubeVideoFormat {\n        format.hasVideo = Boolean(format.qualityLabel);\n        format.hasAudio = Boolean(format.audioBitrate);\n        format.isLive = /\\bsource[/=]yt_(live|premiere)_broadcast\\b/.test(format.url);\n        format.isHLS = /\\/manifest\\/hls_(variant|playlist)\\//.test(format.url);\n        format.isDashMPD = /\\/manifest\\/dash\\//.test(format.url);\n        return format;\n    }\n\n    static async GetHLSFormats(URL: string): Promise<YoutubeVideoFormat[]> {\n        const Formats: YoutubeVideoFormat[] = [];\n\n        try {\n            const Resp = await fetch(URL);\n\n            if (!Resp.ok) {\n                throw new Error(`HTTP error! status: ${Resp.status}`);\n            }\n\n            const TxtResp = await Resp.text();\n\n            if (!TxtResp) {\n                throw new Error('No response body');\n            }\n\n            var parser = new Parser.Parser();\n\n            parser.push(TxtResp);\n            parser.end();\n\n            const Manifest = parser.manifest;\n\n            const audioGroups = Manifest.mediaGroups.AUDIO || {};\n            const audioFormats: { [key: string]: YoutubeVideoFormat } = {};\n\n            for (const groupId in audioGroups) {\n                for (const variant in audioGroups[groupId]) {\n                    const audioVariant = audioGroups[groupId][variant];\n                    const itag = parseInt(audioVariant.uri.match(/itag\\/(\\d+)/)[1]);\n\n                    audioFormats[groupId] = {\n                        itag: itag as keyof typeof formats,\n                        mimeType: 'audio/mp4', // Assumed based on example\n                        qualityLabel: null,\n                        bitrate: null,\n                        audioBitrate: null,\n                        codec: audioVariant.codecs,\n                        type: 'audio',\n                        url: audioVariant.uri,\n                        hasAudio: true,\n                        hasVideo: false,\n                        isLive: false,\n                        isHLS: true,\n                        isDashMPD: false\n                    };\n                }\n            }\n\n            // Process video playlists\n\n            for (const playlist of Manifest.playlists) {\n                const attributes = playlist.attributes;\n                const itag = parseInt(playlist.uri.match(/itag\\/(\\d+)/)[1]);\n                const audioGroupId = attributes.AUDIO;\n\n                const format: YoutubeVideoFormat = {\n                    itag: itag as keyof typeof formats,\n                    mimeType: `video/mp4; codecs=\"${attributes.CODECS}\"`,\n                    qualityLabel: `${attributes.RESOLUTION.height}p`,\n                    bitrate: attributes.BANDWIDTH,\n                    audioBitrate: null,\n                    codec: attributes.CODECS,\n                    type: 'video',\n                    width: attributes.RESOLUTION.width,\n                    height: attributes.RESOLUTION.height,\n                    fps: attributes['FRAME-RATE'],\n                    url: playlist.uri,\n                    hasAudio: audioGroupId ? true : false,\n                    hasVideo: true,\n                    isLive: false,\n                    isHLS: true,\n                    isDashMPD: false\n                };\n\n                if (audioGroupId && audioFormats[audioGroupId]) {\n                    format.audioBitrate = audioFormats[audioGroupId].audioBitrate;\n                }\n\n                Formats.push(format);\n            }\n\n            // Push any audio formats that were not associated with a video format\n\n            for (const groupId in audioFormats) {\n                if (!Formats.some((f) => f.url === audioFormats[groupId].url)) {\n                    Formats.push(audioFormats[groupId]);\n                }\n            }\n        } catch (error) {\n            console.error('Error fetching or parsing the HLS formats:', error);\n            return [];\n        }\n\n        return Formats;\n    }\n}\n","import Axios from 'axios';\n\nimport { YoutubeError, UrlError, YoutubeVideo } from '../classes';\nimport { Util, YoutubeConfig } from '../util';\n\nexport async function GetVideo(\n    URLorID: string,\n    GetHLSFormats: boolean = false,\n    Proxy?: { Host: string; Port: number }\n): Promise<YoutubeVideo> {\n    const videoId = Util.getVideoId(URLorID);\n    if (!videoId) {\n        throw new UrlError();\n    }\n\n    const response = await Axios({\n        url: Util.getApiURL('player'),\n        method: 'post',\n        data: {\n            context: YoutubeConfig.INNERTUBE_CONTEXT,\n            videoId: videoId,\n            playbackContext: {\n                contentPlaybackContext: {\n                    vis: 0,\n                    splay: false,\n                    autoCaptionsDefaultOn: false,\n                    autonavState: 'STATE_NONE',\n                    html5Preference: 'HTML5_PREF_WANTS',\n                    lactMilliseconds: '-1',\n                    signatureTimestamp: YoutubeConfig.STS\n                }\n            }\n        },\n        proxy: Proxy ? { host: Proxy.Host, port: Proxy.Port } : undefined,\n        httpsAgent: new (require('https').Agent)({ rejectUnauthorized: false })\n    });\n\n    const json = (await response.data) as any;\n\n    if (json.playabilityStatus?.status === 'ERROR') {\n        throw new YoutubeError(json.playabilityStatus.reason);\n    }\n\n    const video = new YoutubeVideo(json);\n\n    if (GetHLSFormats) {\n        const hlsUrl = json.streamingData?.hlsManifestUrl;\n\n        if (hlsUrl) {\n            const HLSFormats = await Util.GetHLSFormats(hlsUrl);\n\n            video.liveFormats.push(...HLSFormats);\n        }\n    }\n\n    return video;\n}\n","import m3u8stream from 'm3u8stream';\nimport { PassThrough } from 'stream';\n\nimport { GetVideo } from './GetVideo';\nimport { DownloadOptions } from '../classes';\n\n/**\n * Downloads a YouTube stream using its url or id.\n * @param urlOrId The url or id of the song to download its stream.\n * @param options The options to use for the song.\n */\nexport async function Download(urlOrId: string, options?: DownloadOptions): Promise<m3u8stream.Stream | PassThrough> {\n    const video = await GetVideo(urlOrId, true);\n\n    // This format filter is suitable for live video or music bots.\n    return video.Download((f) => f.isHLS || (f.codec === 'opus' && !f.hasVideo && f.hasAudio), options);\n}\n"],"mappings":"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K,IAAIkB,EAAO,CAAC,CAAC,EAAE,EAC3B,MACJ,KAAKH,EACDf,EAAO,KAAK,IAAIkB,EAAO,CAAC,CAAC,EAAE,EAC3B,KACR,CAEJ,OAAOlB,CACX,CCpGO,IAAMmB,EAAU,CACnB,EAAG,CACC,SAAU,0CACV,aAAc,OACd,QAAS,KACT,aAAc,EAClB,EACA,EAAG,CACC,SAAU,0CACV,aAAc,OACd,QAAS,IACT,aAAc,EAClB,EACA,GAAI,CACA,SAAU,yCACV,aAAc,KACd,QAAS,IACT,aAAc,IAClB,EACA,GAAI,CACA,SAAU,yCACV,aAAc,OACd,QAAS,IACT,aAAc,EAClB,EACA,GAAI,CACA,SAAU,iCACV,aAAc,OACd,QAAS,IACT,aAAc,EAClB,EACA,GAAI,CACA,SAAU,iCACV,aAAc,OACd,QAAS,IACT,aAAc,GAClB,EACA,GAAI,CACA,SAAU,iCACV,aAAc,OACd,QAAS,IACT,aAAc,GAClB,EACA,GAAI,CACA,SAAU,iCACV,aAAc,OACd,QAAS,IACT,aAAc,GAClB,EACA,GAAI,CACA,SAAU,yCACV,aAAc,OACd,QAAS,MACT,aAAc,EAClB,EACA,GAAI,CACA,SAAU,iCACV,aAAc,QACd,QAAS,IACT,aAAc,GAClB,EACA,GAAI,CACA,SAAU,iCACV,aAAc,QACd,QAAS,KACT,aAAc,GAClB,EACA,GAAI,CACA,SAAU,mCACV,aAAc,OACd,QAAS,IACT,aAAc,GAClB,EACA,GAAI,CACA,SAAU,mCACV,aAAc,OACd,QAAS,IACT,aAAc,GAClB,EACA,GAAI,CACA,SAAU,mCACV,aAAc,OACd,QAAS,IACT,aAAc,GAClB,EACA,GAAI,CACA,SAAU,mCACV,aAAc,QACd,QAAS,KACT,aAAc,GAClB,EACA,GAAI,CACA,SAAU,iCACV,aAAc,OACd,QAAS,IACT,aAAc,EAClB,EACA,GAAI,CACA,SAAU,iCACV,aAAc,OACd,QAAS,IACT,aAAc,EAClB,EACA,GAAI,CACA,SAAU,iCACV,aAAc,OACd,QAAS,IACT,aAAc,GAClB,EACA,GAAI,CACA,SAAU,iCACV,aAAc,QACd,QAAS,IACT,aAAc,GAClB,EACA,GAAI,CACA,SAAU,gCACV,aAAc,OACd,QAAS,IACT,aAAc,EAClB,EACA,GAAI,CACA,SAAU,gCACV,aAAc,OACd,QAAS,KACT,aAAc,EAClB,EACA,GAAI,CACA,SAAU,gCACV,aAAc,OACd,QAAS,IACT,aAAc,GAClB,EACA,GAAI,CACA,SAAU,gCACV,aAAc,OACd,QAAS,IACT,aAAc,GAClB,EACA,GAAI,CACA,SAAU,gCACV,aAAc,OACd,QAAS,KACT,aAAc,GAClB,EACA,GAAI,CACA,SAAU,gCACV,aAAc,QACd,QAAS,KACT,aAAc,GAClB,EACA,IAAK,CACD,SAAU,mCACV,aAAc,OACd,QAAS,KACT,aAAc,GAClB,EACA,IAAK,CACD,SAAU,mCACV,aAAc,OACd,QAAS,KACT,aAAc,GAClB,EACA,IAAK,CACD,SAAU,mCACV,aAAc,OACd,QAAS,KACT,aAAc,GAClB,EACA,IAAK,CACD,SAAU,iCACV,aAAc,OACd,QAAS,IACT,aAAc,GAClB,EACA,IAAK,CACD,SAAU,yBACV,aAAc,KACd,QAAS,KACT,aAAc,EAClB,EACA,IAAK,CACD,SAAU,yBACV,aAAc,KACd,QAAS,KACT,aAAc,EAClB,EACA,IAAK,CACD,SAAU,gCACV,aAAc,OACd,QAAS,KACT,aAAc,EAClB,EACA,IAAK,CACD,SAAU,4BACV,aAAc,OACd,QAAS,IACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,4BACV,aAAc,OACd,QAAS,IACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,4BACV,aAAc,OACd,QAAS,IACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,4BACV,aAAc,OACd,QAAS,IACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,4BACV,aAAc,QACd,QAAS,KACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,4BACV,aAAc,QACd,QAAS,MACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,0BACV,aAAc,KACd,QAAS,KACT,aAAc,EAClB,EACA,IAAK,CACD,SAAU,0BACV,aAAc,KACd,QAAS,KACT,aAAc,GAClB,EACA,IAAK,CACD,SAAU,0BACV,aAAc,KACd,QAAS,KACT,aAAc,GAClB,EACA,IAAK,CACD,SAAU,gCACV,aAAc,OACd,QAAS,IACT,aAAc,EAClB,EACA,IAAK,CACD,SAAU,4BACV,aAAc,OACd,QAAS,IACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,8BACV,aAAc,KACd,QAAS,KACT,aAAc,GAClB,EACA,IAAK,CACD,SAAU,8BACV,aAAc,KACd,QAAS,KACT,aAAc,GAClB,EACA,IAAK,CACD,SAAU,2BACV,aAAc,OACd,QAAS,IACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,2BACV,aAAc,OACd,QAAS,KACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,2BACV,aAAc,OACd,QAAS,IACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,2BACV,aAAc,OACd,QAAS,IACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,2BACV,aAAc,QACd,QAAS,KACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,4BACV,aAAc,KACd,QAAS,KACT,aAAc,EAClB,EACA,IAAK,CACD,SAAU,4BACV,aAAc,KACd,QAAS,KACT,aAAc,EAClB,EACA,IAAK,CACD,SAAU,4BACV,aAAc,KACd,QAAS,KACT,aAAc,GAClB,EACA,IAAK,CACD,SAAU,4BACV,aAAc,QACd,QAAS,IACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,4BACV,aAAc,QACd,QAAS,MACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,2BACV,aAAc,QACd,QAAS,IACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,2BACV,aAAc,QACd,QAAS,IACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,2BACV,aAAc,aACd,QAAS,IACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,4BACV,aAAc,OACd,QAAS,IACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,4BACV,aAAc,QACd,QAAS,KACT,aAAc,IAClB,EACA,IAAK,CACD,SAAU,gCACV,aAAc,OACd,QAAS,OAC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","names":["YoutubeError","message","UrlError","FormatError","Axios","m3u8stream","PassThrough","jsVarStr","jsSingleQuoteStr","jsDoubleQuoteStr","jsQuoteStr","jsKeyStr","jsPropStr","jsEmptyStr","reverseStr","sliceStr","spliceStr","swapStr","actionsObjRegexp","actionsFuncRegexp","reverseRegexp","sliceRegexp","spliceRegexp","swapRegexp","decipher","tokens","sig","arr","token","position","extractTokens","body","objResult","funcResult","obj","objBody","funcBody","reverseKey","sliceKey","spliceKey","swapKey","keys","tokenizeRegexp","result","formats","_YoutubeConfig","response","json","player","extractTokens","YoutubeConfig","Parser","videoRegex","validPathDomains","validQueryDomains","Util","id","param","YoutubeConfig","urlOrId","checkUrl","url","format","URL","Formats","Resp","TxtResp","parser","Parser","Manifest","audioGroups","audioFormats","groupId","variant","audioVariant","itag","playlist","attributes","audioGroupId","f","error","Axios","GetVideo","URLorID","GetHLSFormats","Proxy","videoId","Util","UrlError","json","Axios","YoutubeConfig","YoutubeError","video","YoutubeVideo","hlsUrl","HLSFormats","Download","urlOrId","options","GetVideo","f","HttpsProxyAgent","YoutubeVideo","json","Util","formatFilter","options","Proxy","playableFormats","f","filteredFormats","format","FormatError","stream","m3u8stream","downloadChunkSize","remainRetry","startBytes","endBytes","awaitDrain","nowBody","retryTimer","PassThrough","getRangeChunk","response","Axios","Download","reader","chunk","resolve","error","formats","rawFormat","itag","reservedFormat","mimeType","url","YoutubeConfig","decipher"]}